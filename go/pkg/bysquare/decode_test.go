package bysquare_test

import (
	"testing"

	"github.com/xseman/bysquare/go/pkg/bysquare"
)

// TestDecodeSimplePayment tests decoding a simple payment QR code
func TestDecodeSimplePayment(t *testing.T) {
	// This QR was generated by the TypeScript implementation
	qr := "0005C000FSK4RPEG9C62MCH01IOI29VJJC1187BHC75BBH567UER1CVMS5BAKO010L2QMT3QDCST5K9U48H3200GDQEA2R64NOLH6U5648P7UFJHA8TU5JDCR0NB1VH1FVUBQ600"

	result, err := bysquare.Decode(qr)
	if err != nil {
		t.Fatalf("Decode failed: %v", err)
	}

	if len(result.Payments) != 1 {
		t.Fatalf("Expected 1 payment, got %d", len(result.Payments))
	}

	payment := result.Payments[0]

	if payment.Type != 1 {
		t.Errorf("Expected type 1, got %d", payment.Type)
	}

	if payment.Amount != 123.45 {
		t.Errorf("Expected amount 123.45, got %f", payment.Amount)
	}

	if payment.CurrencyCode != "EUR" {
		t.Errorf("Expected EUR, got %s", payment.CurrencyCode)
	}

	if len(payment.BankAccounts) != 1 {
		t.Fatalf("Expected 1 bank account, got %d", len(payment.BankAccounts))
	}

	if payment.BankAccounts[0].IBAN != "SK9611000000002918599669" {
		t.Errorf("Expected IBAN SK9611000000002918599669, got %s", payment.BankAccounts[0].IBAN)
	}

	if payment.Beneficiary == nil {
		t.Fatal("Expected beneficiary to be set")
	}

	if payment.Beneficiary.Name != "Jan Novacek" {
		t.Errorf("Expected beneficiary name 'Jan Novacek', got '%s'", payment.Beneficiary.Name)
	}
}

// TestDecodeWithVariableSymbol tests decoding with variable symbol
func TestDecodeWithVariableSymbol(t *testing.T) {
	// Encode first to get a valid QR
	model := bysquare.DataModel{
		Payments: []bysquare.SimplePayment{
			{
				Type:           1,
				Amount:         100.50,
				CurrencyCode:   "EUR",
				VariableSymbol: "123456",
				Beneficiary:    &bysquare.Beneficiary{Name: "John Doe"},
				BankAccounts: []bysquare.BankAccount{
					{IBAN: "SK9611000000002918599669"},
				},
			},
		},
	}

	qr, err := bysquare.Encode(model)
	if err != nil {
		t.Fatalf("Encode failed: %v", err)
	}

	// Decode it back
	result, err := bysquare.Decode(qr)
	if err != nil {
		t.Fatalf("Decode failed: %v", err)
	}

	if result.Payments[0].VariableSymbol != "123456" {
		t.Errorf("Expected variable symbol '123456', got '%s'", result.Payments[0].VariableSymbol)
	}
}

// TestDecodeInvalidQR tests decoding invalid QR codes
func TestDecodeInvalidQR(t *testing.T) {
	testCases := []struct {
		name string
		qr   string
	}{
		{"empty string", ""},
		{"too short", "000"},
		{"invalid base32", "0000ZZZZZ!!!"},
		{"wrong header", "FFFF000000000000"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			_, err := bysquare.Decode(tc.qr)
			if err == nil {
				t.Errorf("Expected error for %s, got nil", tc.name)
			}
		})
	}
}

// TestRoundTrip tests encode->decode->encode consistency
func TestRoundTrip(t *testing.T) {
	original := bysquare.DataModel{
		InvoiceID: "INV-2024-001",
		Payments: []bysquare.SimplePayment{
			{
				Type:                            1,
				Amount:                          250.75,
				CurrencyCode:                    "EUR",
				PaymentDueDate:                  "20241231",
				VariableSymbol:                  "VS123",
				ConstantSymbol:                  "0308",
				SpecificSymbol:                  "SS456",
				OriginatorsReferenceInformation: "REF789",
				PaymentNote:                     "Test payment",
				BankAccounts: []bysquare.BankAccount{
					{
						IBAN: "SK9611000000002918599669",
						BIC:  "TATRSKBX",
					},
				},
				Beneficiary: &bysquare.Beneficiary{
					Name:   "John Doe",
					Street: "Main Street 123",
					City:   "Bratislava",
				},
			},
		},
	}

	// First encode
	qr1, err := bysquare.Encode(original)
	if err != nil {
		t.Fatalf("First encode failed: %v", err)
	}

	// Decode
	decoded, err := bysquare.Decode(qr1)
	if err != nil {
		t.Fatalf("Decode failed: %v", err)
	}

	// Second encode
	qr2, err := bysquare.Encode(decoded)
	if err != nil {
		t.Fatalf("Second encode failed: %v", err)
	}

	// Both QR codes should be identical
	if qr1 != qr2 {
		t.Errorf("Round trip failed: QR codes don't match\nFirst:  %s\nSecond: %s", qr1, qr2)
	}

	// Verify all fields
	if decoded.InvoiceID != original.InvoiceID {
		t.Errorf("InvoiceID mismatch: got %s, want %s", decoded.InvoiceID, original.InvoiceID)
	}

	if len(decoded.Payments) != len(original.Payments) {
		t.Fatalf("Payment count mismatch: got %d, want %d", len(decoded.Payments), len(original.Payments))
	}

	p1, p2 := decoded.Payments[0], original.Payments[0]

	if p1.Type != p2.Type {
		t.Errorf("Type mismatch: got %d, want %d", p1.Type, p2.Type)
	}

	if p1.Amount != p2.Amount {
		t.Errorf("Amount mismatch: got %f, want %f", p1.Amount, p2.Amount)
	}

	if p1.VariableSymbol != p2.VariableSymbol {
		t.Errorf("VariableSymbol mismatch: got %s, want %s", p1.VariableSymbol, p2.VariableSymbol)
	}

	if p1.PaymentNote != p2.PaymentNote {
		t.Errorf("PaymentNote mismatch: got %s, want %s", p1.PaymentNote, p2.PaymentNote)
	}
}

// TestDecodeWithDiacritics tests decoding payment with diacritics
func TestDecodeWithDiacritics(t *testing.T) {
	original := bysquare.DataModel{
		Payments: []bysquare.SimplePayment{
			{
				Type:         1,
				Amount:       100.00,
				CurrencyCode: "EUR",
				PaymentNote:  "Platba č. 123",
				BankAccounts: []bysquare.BankAccount{
					{IBAN: "SK9611000000002918599669"},
				},
				Beneficiary: &bysquare.Beneficiary{
					Name:   "Ján Nováček",
					Street: "Úzká ulica 5",
					City:   "Žilina",
				},
			},
		},
	}

	// Encode with deburr
	qr, err := bysquare.Encode(original, bysquare.EncodeOptions{
		Deburr: true,
	})
	if err != nil {
		t.Fatalf("Encode failed: %v", err)
	}

	// Decode
	decoded, err := bysquare.Decode(qr)
	if err != nil {
		t.Fatalf("Decode failed: %v", err)
	}

	// Diacritics should be removed
	payment := decoded.Payments[0]
	if payment.PaymentNote != "Platba c. 123" {
		t.Errorf("Expected deburred payment note 'Platba c. 123', got '%s'", payment.PaymentNote)
	}

	if payment.Beneficiary.Name != "Jan Novacek" {
		t.Errorf("Expected deburred name 'Jan Novacek', got '%s'", payment.Beneficiary.Name)
	}

	if payment.Beneficiary.City != "Zilina" {
		t.Errorf("Expected deburred city 'Zilina', got '%s'", payment.Beneficiary.City)
	}
}
